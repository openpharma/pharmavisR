#TODO: need to define new class for survfit i.e. survfit_visr
#overriding plot.surfit in survival
#https://www.rdocumentation.org/packages/survival/versions/3.2-11/topics/plot.survfit


#' @title Plot a visR survfit object
#' 
#' @param x Object of class `survfit_visr`
#' @param ... other arguments passed on to the method
#' @param y_label \code{character} Label for the y-axis. When not specified, the default will do a proposal, depending on the `fun` argument.
#' @param x_label \code{character} Label for the x-asis. When not specified, the algorithm will look for "PARAM" information inside the list structure of the `survfit` object.
#'   Note that this information is automatically added when using visR::estimate_KM and when the input data has the variable "PARAM". If no "PARAM" information is available
#'   "time" is used as label.
#' @param x_units Unit to be added to the x_label (x_label (x_unit)). Default is NULL.
#' @param x_ticks Ticks for the x-axis. When not specified, the default will do a proposal. 
#' @param y_ticks Ticks for the y-axis. When not specified, the default will do a proposal based on the `fun` argument.
#' @param legend_position Specifies the legend position in the plot. Character values allowed are "top" "left" "bottom" "right". Numeric coordinates are also allowed.
#'   Default is "right".
#' @param fun TODO description
#' 
#' 
#' @examples
#' library(survival)
#' library(visR)
#' 
#' # fit KM 
#' km_fit <- survival::survfit(Surv(AVAL, 1-CNSR) ~ TRTP, data=adtte)
#' 
#' # plot curves using base plot function
#' survival:::plot.survfit(km_fit)
#' 
#' # plot same curves using visR plot function
#' 
#' # estimate KM using visR wrapper
#' survfit_object <- visR::estimate_KM(data = adtte, strata = "TRTP")
#'
#' ## Plot survival probability
#' plot(survfit_object, fun = "surv")
#' plot(survfit_object, fun = "pct")
#' 
#' ## Plot cumulative hazard
#' plot(survfit_object, fun = "cloglog")
#'  
#' @return Object of class \code{ggplot}  \code{ggsurvplot}.
#' @exportS3Method graphics::plot

plot.survfit_visr <-
  function(x = NULL,
           ...,
           y_label = NULL,
           x_label = NULL,
           x_units = NULL,
           x_ticks = NULL,
           y_ticks = NULL,
           fun = "surv",
           legend_position = "right") {
    
# Minimal input validation  ----------------------------------------------------

  if (!inherits(x, "survfit_visr")) stop("survfit object is not of class `survfit_visr`")
  if (is.character(legend_position) && ! legend_position %in% c("top", "bottom", "right", "left", "none")){
    stop("Invalid legend position given.")
  } else if (is.numeric(legend_position) && length(legend_position) != 2) {
    stop("Invalid legend position coordinates given.")
  }
  
# Y-label ----------------------------------------------------------------------

  if (is.null(y_label) & is.character(fun)){
    y_label <- base::switch(
      fun,
      surv = "Survival probability",
      log = "log(Survival probability)",
      event = "Failure probability",
      cloglog = "log(-log(Survival probability))",
      pct = "Survival probability (%)",
      logpct = "log(Survival probability (%))",
      cumhaz = "cumulative hazard",
      stop("Unrecognized fun argument")
    )
  } else if (is.null(y_label) & is.function(fun)) {
    stop("Error in plot: No Y label defined. No default label is available when `fun` is a function.")
  }  
  
  if (is.character(fun)){
    .transfun <- base::switch(
      fun,
      surv = function(y) y,
      log = function(y) log(y),
      event = function(y) 1 - y,
      cloglog = function(y) log(-log(y)),
      pct = function(y) y * 100,
      logpct = function(y) log(y *100),
      # survfit_visr object contains an estimate for Cumhaz and SE based on Nelson-Aalen with or without correction for ties
      # However, no CI is calculated automatically. For plotting, the MLE estimator is used for convenience.
      cumhaz = function(y) -log(y), 
      stop("Unrecognized fun argument")
    )
  } else if (is.function(fun)) {
    fun
  } else {
    stop("Error in plot: fun should be a character or a user-defined function.")
  }

# Extended tidy of survfit_visr class + transformation + remove NA after transfo ----
  
  correctme <- NULL
  tidy_object <- tidyme(x)
  
  if ("surv" %in% colnames(tidy_object)) {
    tidy_object[["est"]] <- .transfun(tidy_object[["surv"]])
    correctme <- c(correctme,"est")
  }
  if (base::all(c("upper", "lower") %in% colnames(tidy_object))) {
    tidy_object[["est.upper"]] <- .transfun(tidy_object[["upper"]])
    tidy_object[["est.lower"]] <- .transfun(tidy_object[["lower"]])
    correctme <- c(correctme,"est.lower", "est.upper")
  } 
  
# Adjust -Inf to minimal value -------------------------------------------------
  
  tidy_object[ , correctme] <- sapply(tidy_object[ , correctme],
                                      FUN = function(x) {
                                        x[which(x == -Inf)] <- min(x[which(x != -Inf)], na.rm = TRUE)
                                        return(x)
                                      } 
  )
  
  ymin = min(sapply(tidy_object[ , correctme], function(x) min(x[which(x != -Inf)], na.rm = TRUE)), na.rm = TRUE)
  ymax = max(sapply(tidy_object[ , correctme], function(x) max(x[which(x != -Inf)], na.rm = TRUE)), na.rm = TRUE)
  
  if (fun == "cloglog") {
    if (nrow(tidy_object[tidy_object$est == "-Inf",]) > 0) {
      warning("NAs introduced by y-axis transformation.\n")
    } 
    tidy_object = tidy_object[tidy_object$est != "-Inf",]
  }

# Obtain X-asis label ----------------------------------------------------------

  if (is.null(x_label)){
    if ("PARAM" %in% names(x)) x_label = x[["PARAM"]]
    if (! "PARAM" %in% names(x)) x_label = "time"
    if (!is.null(x_units)) x_label = paste0(x_label, " (", x_units, ")")
  }
  if (is.null(x_ticks)) x_ticks = pretty(x$time, 10)

# Obtain Y-asis label ----------------------------------------------------------
  
  if (is.null(y_ticks) & is.character(fun)){
    y_ticks <- base::switch(
      fun,
      surv = pretty(c(0,1), 5),
      log =  pretty(round(c(ymin,ymax), 0), 5),
      event = pretty(c(0,1), 5),
      cloglog = pretty(round(c(ymin,ymax), 0), 5),
      pct = pretty(c(0,100), 5),
      logpct = pretty(c(0,5), 5),
      cumhaz =  pretty(round(c(ymin,ymax), 0), 5),
      stop("Unrecognized fun argument")
    )
  } else if (is.null(y_label) & is.function(fun)) {
    stop("Error in plot: No Y label defined. No default is available when `fun` is a function.")
  }  

# Plotit -----------------------------------------------------
  
  yscaleFUN <- function(x) sprintf("%.2f", x)
  
  gg <- ggplot2::ggplot(tidy_object, ggplot2::aes(x = time, group = strata)) +
    ggplot2::geom_step(ggplot2::aes(y = est, col = strata)) + 
    ggplot2::scale_x_continuous(name = paste0("\n", x_label),
                                breaks = x_ticks,
                                limits = c(min(x_ticks), max(x_ticks))) +
    ggplot2::scale_y_continuous(name = paste0(y_label, "\n"),
                                breaks = y_ticks,
                                labels = yscaleFUN,
                                limits = c(min(y_ticks), max(y_ticks))) +
    # ggplot2::theme_bw() +
    ggplot2::theme(legend.position = legend_position) +
    # ggplot2::guides(color=ggplot2::guide_legend(override.aes=list(fill=NA))) +
    NULL
  
  class(gg) <- append(class(gg), "ggsurvfit")
  
  return(gg)
}
